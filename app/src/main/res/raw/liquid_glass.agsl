// rda 2025
uniform float3 iResolution;      // viewport (w,h,_)
uniform float4 iGesture;           // mouse drag .xy / click .zw (pixels)
uniform shader iImage1;          // background image
uniform float3 iImageResolution; // image (w,h,_)
uniform float4 uSize;            // x: 0.2..2.0 (zoom)

float2 toUV(float2 frag) { return frag / iResolution.xy; }
float2 uvToFrag(float2 uv) { return uv * iResolution.xy; }

// Aspect-Fit (letterbox) mapping: frag (px) -> image (px)
float2 fitToImagePx(float2 frag, float2 view, float2 img) {
    float sx = view.x / img.x;
    float sy = view.y / img.y;
    float s = min(sx, sy);                // scale (fit)
    float2 size = img * s;
    float2 pad = (view - size) * 0.5;     // center
    float2 local = (frag - pad) / s;      // image px
    return local;
}

half4 fallbackBG(float2 uv) {
    float g = smoothstep(0.0, 1.0, uv.y);
    g += 0.06 * sin(uv.y * 180.0);
    return half4(g*0.9, g*0.95, 1.0, 1.0);
}

// Now readBG works with uv but samples according to aspect-fit
half4 readBG(float2 uv) {
    if (iImageResolution.x > 0.5 && iImageResolution.y > 0.5) {
        float2 frag = uvToFrag(uv);
        float2 p = fitToImagePx(frag, iResolution.xy, iImageResolution.xy);
        p = clamp(p, float2(0.0), iImageResolution.xy);
        return iImage1.eval(p); // bitmap px coordinates
    }
    return fallbackBG(uv);
}

half4 main(vec2 fragCoord) {
    float2 res = iResolution.xy;
    float2 uv  = toUV(fragCoord);

    // If no mouse, use center
    float2 mouse = iGesture.xy;
    if (length(mouse) < 1.0) mouse = res * 0.5;
    float2 m2 = uv - mouse / res;
    float zoom = clamp(uSize.x, 0.001, 5.0);

    // Original “rounded box” calculation (keep character)
    float rx = pow(abs(m2.x * res.x / res.y) / zoom, 8.0);
    float ry = pow(abs(m2.y) / zoom, 8.0);
    float roundedBox = rx + ry;

    // ---- SCALE ONLY THE AREA ----
    float rb = roundedBox / zoom; // small zoom -> small area, big zoom -> wide area

    // Original constants, but with rb
    float rb1 = clamp((1.0  - rb * 10000.0) * 8.0, 0.0, 1.0);
    float rb2 = clamp((0.95 - rb * 9500.0) * 16.0, 0.0, 1.0)
              - clamp(pow(0.9 - rb * 9500.0, 1.0) * 16.0, 0.0, 1.0);
    float rb3 = (clamp((1.5 - rb * 11000.0) * 2.0, 0.0, 1.0)
              - clamp(pow(1.0 - rb * 11000.0, 1.0) * 2.0, 0.0, 1.0));

    float transition = smoothstep(0.0, 1.0, rb1 + rb2);

    half4 baseTex = readBG(uv);
    if (transition <= 0.0) return baseTex;

    // Lens calculation, also using rb
    float2 lens = (uv - 0.5) * (1.0 - rb * 5000.0) + 0.5;

    // 9x9 sampling (uv step)
    float2 stepU = float2(0.5 / res.x, 0.0);
    float2 stepV = float2(0.0, 0.5 / res.y);

    half4 acc = half4(0.0);
    float total = 0.0;

    for (float x = -4.0; x <= 4.0; x++) {
        for (float y = -4.0; y <= 4.0; y++) {
            float2 o = x * stepU + y * stepV;
            half4 s = readBG(clamp(lens + o, 0.0, 1.0));
            acc += s;
            total += 1.0;
        }
    }
    half4 blurred = acc / half(total);

    // Gradient highlights
    float g1 = clamp((clamp(m2.y, 0.0, 0.2) + 0.1) / 2.0, 0.0, 1.0);
    float g2 = clamp((clamp(-m2.y, -1000.0, 0.2) * rb3 + 0.1) / 2.0, 0.0, 1.0);
    float gradient = g1 + g2;

    half4 lighting = clamp(blurred + half4(rb1) * half(gradient) + half4(rb2) * half(0.3), 0.0, 1.0);
    return mix(baseTex, lighting, half(transition));
}
